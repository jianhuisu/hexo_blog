---
title:      IMserver的实现
categories : 
 - C
tags:
    - socket
---

server.c
    
    #include <stdio.h>
    #include <sys/socket.h>
    #include <netinet/in.h> // 网络地址转换
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <signal.h> // 信号集
    
    
    
    int main(int argc, const char * argv[]) {
        
        int server_fd;
        struct sockaddr_in server_addr;
        
        /*
         参数说明
         
         
            SOCK_STREAM  tcp
            SOCK_DGRAM udp    视频 音频 （允许部分失真）
         
         函数介绍
         
         socket函数可以创建一个套接字。默认情况，内核会认为socket函数创建的套接字是
         主动套接字（active socket），它存在于一个连接的客户端。
         而服务器调用listen函数告诉内核，该套接字是被服务器而不是客户端使用的，
         即listen函数将一个主动套接字转化为监听套接字（下文以 listenfd 表示）。监听套接字可以接受来自客户端的连接请求。
         
         如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。
         
         */
        server_fd = socket(AF_INET,SOCK_STREAM,0);
        
        // 申请内存 地址清零/初始化
        memset(&server_addr,0,sizeof(server_addr));
        
        /*
            获取IPV4的地址信息；
         */
        server_addr.sin_family = AF_INET;
        
        /*
            将监听端口的整型变量从主机字节顺序转变成网络字节顺序
         
            字节序问题只有在读取的时候才会出现
         
            大端法  人类习惯的表示方式。12345 一万两千三百四十五
            小端法  计算机电路从低位开始处理效率高 五万四千三百二十一
         
         在设定地址之前务必对地址 进行 主机字节序到网络字节序的转换,否则会引起 
         todo ？ 网络上进行 字符串/文件传输时 是否需要进行字节序转换 ？
         
            我理解的是 需要 ，这样 不论数据的发送或者接收 都需要进行字节序转换
         */
        server_addr.sin_port   = htons(9100);
        
        /*
         如果你的服务器有多个网卡（每个网卡上有不同的IP地址），而你的服务（不管是在udp端口上侦听，还是在tcp端口上侦听），出于某种原因：
         可能是你的服务器操作系统可能随时增减IP地址，也有可能是为了省去确定服务器上有什么网络端口（网卡）的麻烦 —— 可以要在调用bind()的时候，告诉操作系统：“我需要在 yyyy 端口上侦听，所有发送到服务器的这个端口，不管是哪个网卡/哪个IP地址接收到的数据，都是我处理的。”这时候，服务器程序则在0.0.0.0这个地址上进行侦听。例如：
         
              回环地址 127.0.0.1 ： 80 端口
         局域网地址 172.16.225.67 : 80 端口
         外网接口 111.198.190.132 ：80 端口
         
         不论外部信息发送到上述三个IP中任意一个的 80端口 都可以被 server接收
         
         127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。
         
         因为 tcp udp 都具有自己的端口号（范围均为 0-2^16-1） 所以 udp :80 是不同于 tcp:80 的地址
         
         所以 利用三元组（ip地址，协议，端口）就可以标识唯一的网络的进程
         
         */
         
        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        
        /* todo 为什么这里不能用 (struct sockaddr_in *) &server_addr
         Incompatible pointer types passing 'struct sockaddr_in *' to parameter of type 'const struct sockaddr *'
         
         由调度程序
         目标进程 发送进程
         
         将ip+port 与 进程的fd之间的映射关系注册到 管理进程维护的表中
         
         */
        if( bind(server_fd,(struct sockaddr_in *) &server_addr,sizeof(struct sockaddr_in) ) < 0 ){
            perror("socket bind error");
        }
        
        /*
         
         sockfd 一个已绑定未被连接的套接字描述符
         backlog 连接请求队列(queue of pending connections)的最大长度
         
            listen函数使用主动连接套接字变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务进程。
         
             (1) 执行listen 之后套接字进入被动模式。
             (2) 队列满了以后，将拒绝新的连接请求。客户端将出现连接D 错误WSAECONNREFUSED。
             (3) 在正在listen的套接字上执行listen不起作用
         
         */
        if(listen(server_fd,4) < 0 ){
            perror("listen op fail");
        }
        
        // insert code here...
        printf(" server start success fd is : %d \n",server_fd);
        
        // 如何使该进程作为daemon运行
        /*
            采用多进程的方式 可同时处理多个来自于不同客户端的 socket 连接。
         
            父进程进行监听,分配 子进程进行实际的 交互
         
             一般的，父进程在生成子进程之后会有两种情况：一是父进程继续去做别的事情，类似上面举的例子；另一是父进程啥都不做，一直在wait子进程退出。
             SIGCHLD信号就是为这第一种情况准备的，它让父进程去做别的事情，而只要父进程注册了处理该信号的函数，在子进程退出时就会调用该函数，
             在函数中wait子进程得到终止状态之后再继续做父进程的事情。
         
             最后，我们来明确以下二点：
             1)凡父进程不调用wait函数族获得子进程终止状态,回收子进程,子进程在退出后都会变成僵尸进程。
             2)SIGCHLD信号可以异步的通知父进程有子进程终止
         
            在进程树中 子进程终止后,会向父进程发送一个信号,通知父进程回收子进程的进程标示符。进程如何处理信号有三种选择。
         
         1）忽略该信号。有些信号表示硬件异常，例如，除以0或访问进程地址空间以外的单元等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。
         
         2）按系统默认处理方式。
         
         3）提供一个函数，信号发生时调用这个函数，成为捕捉该信号。以实现按用户自定义的方式来处理信号。
         
            具体有以下几种情况
         
             父进程在子进程退出时仍在运行
         
                父进程wait() 子进程退出信号,回收子进程
                父进程提前注册 信号处理函数, 异步处理子进程
                父进程不负责对子进程进行回收，转交由内核（init进程 ，pid 为 1 ） 代为处理
         
            父进程先于子进程终止
         
                子进程退出后无进程负责回收,变成僵尸进程，占据一个进程id号
         
         */
        // linux 下 SIGCLD 就是 SIGCHLD
        signal(SIGCHLD,SIG_IGN);
        
        socklen_t client_len;
        int client_fd;
        struct sockaddr_in client_addr;
        char buffer[140];
        pid_t pid; // 子进程的 pid
        
        // 如何使 daemon 运行
        while(1){
            
            printf("wait connect  \n");
            client_len = sizeof(client_addr);
            
            /*
                主动阻塞主进程的执行 直至监听端口接收到客户端数据  唤醒主进程
                ?? client_fd 才是真正与客户端进行通讯的socket文件标示 server_fd socket文件中应该保存的是 客户端连接请求队列
                两点确定一条通信通道
             */
            if( (client_fd = accept(server_fd,(struct sockaddr_in *) &client_addr,&client_len)) == -1 ){
                perror("get connect from queue faild");
            }
            
            /*
                子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。
                无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设
             */
            
            pid = fork();
            
            // 子进程
            if(pid == 0){
                
                // inet_ntoa 将一个32位网络字节序的二进制IP地址转换成相应的点分十进制的IP地址
                printf("server:get connect from %s port: %d \n",inet_ntoa(client_addr.sin_addr),client_addr.sin_port);
                send(client_fd,"hello world\n",13,0);
                
                /*
                    客户端发送的数据会存储在接收缓存区
                    1）recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；
                2）如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，
                 recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕。
                 当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中
                 （注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的）；
                 
                    ?？ 如果接受缓存区数据量远大于 buff 的容量 ，岂不是要溢出了
                 */
                int rs = 1;
                char buff[100];
                size_t  buflen;
                
                while(rs)
                {
                    /*
                        recv函数返回 实际copy的字节数。
                       如果recv在copy时出错，那么它返回SOCKET_ERROR；
                       如果recv函数在等待协议接收数据时网络中断了，那么它返回0
                     
                     */
                    
                    buflen = recv(client_fd, buff, sizeof(buff), 0);
                    if(buflen < 0){
                        
                        rs = 0;
                        perror("buflen is letter then buflen");
                        
                    } else if(buflen == 0){
                        
                        // 这里表示对端的socket已正常关闭.
                        rs = 0;
                        perror("network outage");
                        
                    } else {
                        
                        if(buflen != sizeof(buff)){
                            rs = 0;
                        }else{
                            rs = 1;// 需要再次读取
                        }
                        
                    }
                    
                        
                }
                
                printf("receive message: %s \n",buff);
                
                // ？如何判断远程客户端是否主动断开连接呢 ？ 服务端如何主动断开与客户端的连接呢
                close(client_fd);
                printf("child process exit \n");
                exit(0);
                
            }else if(pid > 0){
                // 父进程
                printf("fork once \n");
            } else {
                printf("fork fail \n");
            }
            
            
        }
        
    }

##### 编写程序

服务端实现

main.c

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <arpa/inet.h>
	#include <netinet/in.h>
	#include <string.h>
	#include <signal.h>

	#define LISTEN_PORT 9006
	#define BACKLOG 5
	#define MAX_RECEIVE 14

	int main(void)
	{
		int fd;
		int cfd; // client fd
		int recv_len;
		struct sockaddr_in serv_addr, client_addr;
		char buffer[MAX_RECEIVE];
		int fid;

		socklen_t clin_len;

		fd = socket(AF_INET,SOCK_STREAM,0);
		printf("socket fd is %d \n",fd);


		memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(LISTEN_PORT);
		serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

		if( bind( fd,(struct sockaddr *) &serv_addr, sizeof(struct sockaddr) ) < 0 )
		{
			perror("socket bind fail\n");
			exit(1);
		}


		if( listen(fd, BACKLOG) < 0 )
		{
			perror("socket listen error\n");
			exit(1);
		}

	    signal(SIGCLD,SIG_IGN);

		// 等待处理来自客户端的链接请求
		int is_continue_receive ;
		while(1)  //循环监听客户端，永远不停止，所以，在本项目中，我们没有心跳包。
		{
			puts("wait connect ...");
			clin_len = sizeof(client_addr);
			if( ( cfd = accept(fd, (struct sockaddr *) &client_addr, &clin_len ) ) == -1 )
			{
				perror("accept connect error");
				exit(1);
			}
			printf("server:get connection from %s\n", inet_ntoa(client_addr.sin_addr) );

	        fid = fork();


			if( fid > 0)  {

			    // 父进程
	            printf(" new connect created \n");


			} else if (fid == 0) {

			    // 子进程
	//		    recv_len = recv(cfd,buffer,MAX_RECEIVE,0);
	//            printf("PID %d recv receive %d bytes \n",getpid(),recv_len);
	//            printf(" %s \n",buffer);
	            send(cfd,"hello worl\n",13,0);
	            close(cfd);
	            exit(0);


			} else if (fid < 0 ) {
			    perror("fork child process  error");
			}

		}

	    // 停止 socket server
	    if( close(fd) == 0 )
		{
			perror("socket close successful\n");
			exit(0);
		}
		else
		{
			perror("socket close fail\n");
			exit(1);
		}

		return 0;

	}


客户端实现

user.c

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <arpa/inet.h>
	#include <netinet/in.h>
	#include <string.h>
	#include <signal.h>

	#define BACKLOG 5
	#define REMOTE_PORT 9006
	#define MAX_RECEIVE 14
	#define REMOTE_ADDR "10.71.1.101"

	int main(void)
	{
		int fd;
		int cfd; // client fd
		struct sockaddr_in serv_addr, client_addr;
		char buf[MAX_RECEIVE];

		fd = socket(AF_INET,SOCK_STREAM,0);


	    if(fd == -1)
	    {
	        perror("server socket create error");
	    }
	    else
	    {
	        printf("server socket fd is %d \n",fd);
	    }

	    memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(REMOTE_PORT);
		serv_addr.sin_addr.s_addr = inet_addr(REMOTE_ADDR);

	    if( connect( fd,(struct sockaddr*) &serv_addr, sizeof(struct sockaddr)) == -1 ){

	        perror("connect failed");
	    } else {

	        perror("connect success");
	        recv(fd,buf,MAX_RECEIVE,0);  //将接收数据打入buf，参数分别是句柄，储存处，最大长度，其他信息（设为0即可）。
	        printf("Received:%s \n",buf);

	    }

	    // 停止 socket server
	    if( close(fd) == 0 )
		{
			perror("socket close successful\n");
			exit(0);
		}
		else
		{
			perror("socket close fail\n");
			exit(1);
		}

		return 0;

	}

##### 编译程序

我的开发环境

	[machine_su@vagrant-centos65 ~]$ cat /etc/centos-release
	CentOS release 6.5 (Final)
	[machine_su@vagrant-centos65 ~]$ gcc -v
	Thread model: posix
	gcc version 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC)

因为开发环境虚拟机共享目录的权限问题，所以我自己写了一个简单shell，命令名为 **t**  ，可以把编译生成的可执行文件输出到指定文件夹，并执行

	[root@vagrant-centos65 ~]# which t
	/root/bin/t
	[root@vagrant-centos65 ~]# cat /root/bin/t
	#! /bin/bash
	gcc -o /home/machine_su/"$1".out $1
	/home/machine_su/"$1".out


##### 运行程序

首先，启动服务端程序，监听 9006 端口

	[root@vagrant-centos65 webServer]# t main.c
	socket fd is 3
	PID:3506 PPID:3500 wait connect ...

检查端口是否监听成功

	[root@vagrant-centos65 ~]# netstat -ntpl | grep 9006
	tcp        0      0 0.0.0.0:9006                0.0.0.0:*                   LISTEN      3506/main.c.out

启动客户端程序，向服务端发起连接请求

	[root@vagrant-centos65 webServer]# t user.c
	server socket fd is 3
	connect success: Success
	Received:if you see th

我们可以在 user.c 界面中发送信息

	[root@vagrant-centos65 webServer]# t user.c
	server socket fd is 3
	connect success: Success
	Received:if you see th

	sujianhui like cf  // 这是命令行中输入发送的信息

	----------entry------------

服务端可以接收到

	[root@vagrant-centos65 webServer]# t main.c
	socket fd is 3
	PID:3506 PPID:3500 wait connect ...
	server:get connection from 10.71.1.101 : fd : 4
	fork once
	 new connect created
	PID:3506 PPID:3500 wait connect ...
	fork once

	receive Message : sujianhui like cf ____receive Message buflen is : 50 // 这里是接收到的信息


##### 测试程序
我们可以使用 tcpdump 来监测通讯过程

	[root@vagrant-centos65 ~]# tcpdump -i any tcp port 9006

##### 维护与调试

为了便于理解，我并没有对上述实现进行函数封装，一些地方也使用了硬编码，而且以上实例只不过是实现了最基本的多进程IO模型。在下一篇笔记中，我会把实例改造成 多路复用IO 的 Web服务器。


# 知识点

##### 什么是fd

在Linux中，内核会为每一个进程分配一个私有的文件表，我们可以将这个文件表理解为一个数组，key 就是 fd ，value 是一个指针，指向该进程在执行过程中所打开的文件对象，对于一个进程而言，fd 是有阈值的，使用 **ulimit -n** 命令可以查看当前系统所设置的最大值。每个进程的前三位 fd 0/1/2 被stdin/stdout/stderr占用，这个是固定的。
