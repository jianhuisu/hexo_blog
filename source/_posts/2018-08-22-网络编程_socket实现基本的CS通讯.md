---
layout:     post
title:      网络编程_socket实现基本的CS通讯
subtitle:   网路编程 套接字 socket web server
date:       2018-08-10
author:     machine_su
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - 网络编程
---

# 网络编程

网络编程的定义：使用套接字来达到进程间通信。socket 是 TCP/IP 协议的实现 。在 socket 编程中，我们可以使用 IP+port  的组合方式确定通讯的主机以及主机上的应用/进程。

	IP 定位 host
	port 定位 进程

## 常用函数

首先了解一下socket编程基础函数


##### socket()

创建套接字描述符 (socket descriptor) 简写 sfd ，该函数向内核申请创建 socket 文件，内核向进程返回该文件描述符

	fd = socket(AF_INET, SOCK_STREAM, 0)

##### connect()

	connect( fd,(struct sockaddr*) &serv_addr, sizeof(struct sockaddr))

参数2是包含了目标地址 IP、port、协议族等信息的数据结构,该函数使用fd向目标地址serv_addr发起连接请求，返回值
为 -1 连接错误，返回值大于0 ，连接正常

##### bind()

	bind( fd,(struct sockaddr *) &serv_addr, sizeof(struct sockaddr) )

将声明的套接字地址结构 serv_addr 与 套接字描述符 fd 绑定( 即 addr 与 fd 是唯一对应关系)。系统通讯信息存储socket_addr, 当一个连接到达内核时, 内核会循环socket_addr找到与端口绑定的fd,通过fd与进程通信

##### listen()

	listen(fd, BACKLOG)

函数通知内核  更改 fd属性由默认的主动套接字变为被动套接字,此时该套接字可以接受来自客户端的链接请求 (相当于此时新增队列变量,存储来自客户端连接请求)。此时fd升级为侦听描述符fd (注意:一个监听进程与listen_fd是唯一对应关系 )

	Tips : 客户端作为发起 socket 请求的主动实体
		   服务器作为监听 socket 请求的被动实体

##### accept()

	accept(fd, (struct sockaddr *) &client_addr, &clin_len )

等待来自客户端的链接请求到达侦听描述符 fd,在 addr 等待连接的队列中保存该客户端socket地址 并返回一个 已连接描述符(connected descriptor ) 已连接描述符供 UNIX I/O 函数使用与客户端通信。注意:一个客户端连接对应一个connected_sfd这种机制使得我们可以并发处理客户端连接。应用通过connected_sfd与客户端 client_sfd 进行通信

##### socket的地址结构

这里补充说明一下上文的serv_addr结构

    // _in 后缀表示互联网的 socketaddr_in  表示互联网的socket地址结构  即被动连接实体的套接字地址 |  服务器套接字地址
    struct socketaddr_in
    {
        uint16_t   sin_family;  // AF_INET 表示使用 32 位 IP 地址
        uint16_t   sin_port;
        struct in_addr   sin_addr;
        unsigned char  sin_zero[8];
    }

    // 本地socket地址结构   SA 是 socket addr 的缩写
    struct sockaddr
    {
        uint16_t   sa_family;  // 协议族
        char       sa_data[14]; // 地址数据
    }


# 实现

大话设计模式一书中有句话，大概意思是一个完整的知识体系并不是一蹴而就，而是经过不断地演变、完善而成。这句话深得我心，学习的精华在于推演的过程，不能知其然不知其所以然。下面我们通过一个客服系统的实现，来循序渐进的学习网络编程


##### 确定程序目标

使用 c 的socket函数实现自动回复消息的客服系统，多(客户端)对一（服务端）

##### 设计程序

采用 客户端->服务端的编程模型

服务端：接收客户端发送的信息，并返回接收到的信息

1. 创建socket文件
1. 绑定socket
1. 监听通讯端口
1. 主进程读取客户端连接，为每一个客户端连接分配一个子进程，子进程负责实际的信息接收与发送，客户端断开连接后，销毁该子进程


客户端：通过shell向服务端发送信息，接收服务端的回复并显示

1. 创建socket
1. 连接服务端socket，向服务端发送信息
1. 输入空行断开连接


##### 编写程序

服务端实现

main.c

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <arpa/inet.h>
	#include <netinet/in.h>
	#include <string.h>
	#include <signal.h>

	#define LISTEN_PORT 9006
	#define BACKLOG 5
	#define MAX_RECEIVE 14

	int main(void)
	{
		int fd;
		int cfd; // client fd
		int recv_len;
		struct sockaddr_in serv_addr, client_addr;
		char buffer[MAX_RECEIVE];
		int fid;

		socklen_t clin_len;

		fd = socket(AF_INET,SOCK_STREAM,0);
		printf("socket fd is %d \n",fd);


		memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(LISTEN_PORT);
		serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

		if( bind( fd,(struct sockaddr *) &serv_addr, sizeof(struct sockaddr) ) < 0 )
		{
			perror("socket bind fail\n");
			exit(1);
		}


		if( listen(fd, BACKLOG) < 0 )
		{
			perror("socket listen error\n");
			exit(1);
		}

	    signal(SIGCLD,SIG_IGN);

		// 等待处理来自客户端的链接请求
		int is_continue_receive ;
		while(1)  //循环监听客户端，永远不停止，所以，在本项目中，我们没有心跳包。
		{
			puts("wait connect ...");
			clin_len = sizeof(client_addr);
			if( ( cfd = accept(fd, (struct sockaddr *) &client_addr, &clin_len ) ) == -1 )
			{
				perror("accept connect error");
				exit(1);
			}
			printf("server:get connection from %s\n", inet_ntoa(client_addr.sin_addr) );

	        fid = fork();


			if( fid > 0)  {

			    // 父进程
	            printf(" new connect created \n");


			} else if (fid == 0) {

			    // 子进程
	//		    recv_len = recv(cfd,buffer,MAX_RECEIVE,0);
	//            printf("PID %d recv receive %d bytes \n",getpid(),recv_len);
	//            printf(" %s \n",buffer);
	            send(cfd,"hello worl\n",13,0);
	            close(cfd);
	            exit(0);


			} else if (fid < 0 ) {
			    perror("fork child process  error");
			}

		}

	    // 停止 socket server
	    if( close(fd) == 0 )
		{
			perror("socket close successful\n");
			exit(0);
		}
		else
		{
			perror("socket close fail\n");
			exit(1);
		}

		return 0;

	}


客户端实现

user.c

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <arpa/inet.h>
	#include <netinet/in.h>
	#include <string.h>
	#include <signal.h>

	#define BACKLOG 5
	#define REMOTE_PORT 9006
	#define MAX_RECEIVE 14
	#define REMOTE_ADDR "10.71.1.101"

	int main(void)
	{
		int fd;
		int cfd; // client fd
		struct sockaddr_in serv_addr, client_addr;
		char buf[MAX_RECEIVE];

		fd = socket(AF_INET,SOCK_STREAM,0);


	    if(fd == -1)
	    {
	        perror("server socket create error");
	    }
	    else
	    {
	        printf("server socket fd is %d \n",fd);
	    }

	    memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(REMOTE_PORT);
		serv_addr.sin_addr.s_addr = inet_addr(REMOTE_ADDR);

	    if( connect( fd,(struct sockaddr*) &serv_addr, sizeof(struct sockaddr)) == -1 ){

	        perror("connect failed");
	    } else {

	        perror("connect success");
	        recv(fd,buf,MAX_RECEIVE,0);  //将接收数据打入buf，参数分别是句柄，储存处，最大长度，其他信息（设为0即可）。
	        printf("Received:%s \n",buf);

	    }

	    // 停止 socket server
	    if( close(fd) == 0 )
		{
			perror("socket close successful\n");
			exit(0);
		}
		else
		{
			perror("socket close fail\n");
			exit(1);
		}

		return 0;

	}

##### 编译程序

我的开发环境

	[machine_su@vagrant-centos65 ~]$ cat /etc/centos-release
	CentOS release 6.5 (Final)
	[machine_su@vagrant-centos65 ~]$ gcc -v
	Thread model: posix
	gcc version 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC)

因为开发环境虚拟机共享目录的权限问题，所以我自己写了一个简单shell，命令名为 **t**  ，可以把编译生成的可执行文件输出到指定文件夹，并执行

	[root@vagrant-centos65 ~]# which t
	/root/bin/t
	[root@vagrant-centos65 ~]# cat /root/bin/t
	#! /bin/bash
	gcc -o /home/machine_su/"$1".out $1
	/home/machine_su/"$1".out


##### 运行程序

首先，启动服务端程序，监听 9006 端口

	[root@vagrant-centos65 webServer]# t main.c
	socket fd is 3
	PID:3506 PPID:3500 wait connect ...

检查端口是否监听成功

	[root@vagrant-centos65 ~]# netstat -ntpl | grep 9006
	tcp        0      0 0.0.0.0:9006                0.0.0.0:*                   LISTEN      3506/main.c.out

启动客户端程序，向服务端发起连接请求

	[root@vagrant-centos65 webServer]# t user.c
	server socket fd is 3
	connect success: Success
	Received:if you see th

我们可以在 user.c 界面中发送信息

	[root@vagrant-centos65 webServer]# t user.c
	server socket fd is 3
	connect success: Success
	Received:if you see th

	sujianhui like cf  // 这是命令行中输入发送的信息

	----------entry------------

服务端可以接收到

	[root@vagrant-centos65 webServer]# t main.c
	socket fd is 3
	PID:3506 PPID:3500 wait connect ...
	server:get connection from 10.71.1.101 : fd : 4
	fork once
	 new connect created
	PID:3506 PPID:3500 wait connect ...
	fork once

	receive Message : sujianhui like cf ____receive Message buflen is : 50 // 这里是接收到的信息


##### 测试程序
我们可以使用 tcpdump 来监测通讯过程

	[root@vagrant-centos65 ~]# tcpdump -i any tcp port 9006

##### 维护与调试

为了便于理解，我并没有对上述实现进行函数封装，一些地方也使用了硬编码，而且以上实例只不过是实现了最基本的多进程IO模型。在下一篇笔记中，我会把实例改造成 多路复用IO 的 Web服务器。


# 知识点

##### 什么是fd

在Linux中，内核会为每一个进程分配一个私有的文件表，我们可以将这个文件表理解为一个数组，key 就是 fd ，value 是一个指针，指向该进程在执行过程中所打开的文件对象，对于一个进程而言，fd 是有阈值的，使用 **ulimit -n** 命令可以查看当前系统所设置的最大值。每个进程的前三位 fd 0/1/2 被stdin/stdout/stderr占用，这个是固定的。
