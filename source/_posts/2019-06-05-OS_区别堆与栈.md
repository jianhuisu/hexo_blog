---
title:      堆跟栈
categories : 
 - OS
tags:
    - C
---
## 开篇点题

堆跟栈是两个概念
数据结构中存在堆,栈 两种结构
内存管理中存在堆区,栈区两种数据存储区域


## 数据结构中的堆,栈

## 堆 heap

堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：

（1）堆中某个节点的值总是不大于或不小于其父节点的值；
（2）堆总是一棵完全二叉树

堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。最小堆中,父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。
堆常用来实现优先队列，堆的存取是随意的.

## 栈 stack 

    栈（stack）在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 别称FILO (first in last out)结构

！！！由于历史原因,导致我们平时所连读的`堆栈`实际上是指 stack

平时进行递归计算时,如果递归次数过多,函数的局部变量,参数,返回值都会被push到栈中,占用大量栈空间.而迭代采用循环结构,不需要反复调用函数和占用额外的内存

## 队列 queue

    队列 queue 队尾插入,队头删除的线性表. 别称 FIFO(first in first out)结构

## 内存管理中的堆区与栈区

### 堆内存区
    
    由程序员控制创建与销毁,用来存储实例(什么是实例? 可以理解为代码中使用new,malloc 创建的对象,那么这个对象可以被视为一个实例,面试官经常在会问到,为什么new操作比较消耗时间,因为new操作符号会控制程序在heap区申请空间)

    malloc() 是操作系统实现的内存调用函数

    存储在堆内存区的数据在程序运行结束后由OS回收,但是如果在程序执行期间没有对堆内的垃圾数据进行回收,积少成多后可能会造成内存泄漏.


那么问题来了,数组存储在栈中还是堆中呢?

在官方的PHP实现内部，所有变量使用同一种数据结构(zval)来保存，而这个结构同时表示PHP中的各种数据类型。 它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。

变量的值使用 zvalue_value 联合体保存

这个取决于数据的声明方式:

    1.要是全局静态常量字符组，那就在静态区
    2.模块内部的话大部分都是在栈中
    3.手动分配地址在堆中,所有malloc的空间都是在堆中申请

    那么数组到底是存储在堆中还是栈中呢?java中的数组存储在堆中

### 栈内存区

栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，
是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。
栈内存的更新速度很快，因为局部变量的生命周期都很短

###  堆区与栈区的比较

### 堆区和栈区是如何联系起来的

 那么堆和栈是怎么联系起来的呢?

    $a = new User();

     我们刚刚说过给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。
如果当int [] arr=null;

              arr不做任何指向，null的作用就是取消引用数据类型的指向。

              当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。

             所以堆与栈的区别很明显：

            1.栈内存存储的是局部变量而堆内存存储的是实体；

            2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；

            3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。


重点:栈空间的大小是由操作系统控制的,如何查看系统的栈空间大小

    ulimit -s 
    8192 KB

同样,我们可以使用 ulimit 命令自定义栈空间大小

## 堆溢出 栈溢出 段溢出

段: 进程控制段(PCB)


进程的申请到的内存空间可以分为4段  

栈空间 
堆空间
数据段
代码段

栈空间  堆空间   属于动态区域
数据段  代码段  属于静态区域

程序在各部分的流转过程

    1 主函数进栈
    2 主函数中声明数组 arr = [] ; 主函数在堆空间开辟内存 存储数据实体 实体的起始地址作为返回值赋值给 arr , 
    3 arr 的值为实体数据在堆中的地址,这种数据称为引用数据类型
    4 主函数调用 arr = null; 解除 arr 与 实体数据地址的引用关系, arr中不在存储实体数据的地址 但是实体数据依然在堆空间中存在,需要使用free进行释放
    5 主函数声明 int age = 15; 该变量存储在栈中
    6 主函数声明常量 const lifeLongest=100 ,该常量不会变动,所以存储在方法区,用时直接读取即可

    进程可以占用的内存大小是没有明确的限制

静态成员变量 / 静态成员方法 一般用来对 对象共享数据，共享数据意味着节省空间
类中的静态方法在类加载时就已经在静态存储区中分配内存，但是其他成员方法需要等待

new 后才可以在 堆中 分配内存，没有分配内存的程序是无法运行的




## 参考资料

这个非常详细 https://www.jianshu.com/p/5f148c3e4f7d

https://blog.csdn.net/pt666/article/details/70876410
