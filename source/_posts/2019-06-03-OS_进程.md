---
title:      进程的基本概念
categories : 
 - OS
tags:
    - C
---

进程

	进程存在于操作系统之中

## 进程的状态

	就绪状态:ready当一个进程获得了除CPU以外的一切所需资源，一旦得到CPU即可运行
	执行状态:获得CPU程序正在执行,多CPU系统可同时存在多个当前进程
	阻塞状态:block进程由于某种原因无法继续执行,放弃CPU变为暂停状态(例如等待IO、申请缓存空间等)
	创建状态:create进程拥有了自己的PCB,但是还未进主存,不能被调度
	终止状态:进程结束后,清除PCB,返还PCB空间

	挂起状态:suspend()原语
	激活状态:active()原语

## 进程状态的切换

1.进程阻塞过程

	正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻 塞原语 block 把自己阻塞。
	可见，进程的阻塞是进程自身的一种主动行为。
	进入 block 过程 后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状 态由“执行”改为“阻塞”，
	并将 PCB 插入阻塞队列。
	如果系统中设置了因不同事件而阻塞 的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列
	最后，转调度程序 进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，
	保留被阻塞进程的处理 机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。

2.进程唤醒过程

	首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪,然后再将该PCB插入到就绪队列中。block 原语和 wakeup 原语是一对作用刚好相反的原语。
	因此，如果在某进程中调用了阻塞原语(进程本身自己主动调用block原语 阻塞自己，因为对临界资源是否使用完毕 由进程自己决定,调度程序无法感知),
	则必须在与之相合作的另一进程中或其他相关的进程中安排唤醒原语，以能唤醒阻塞进程;
	否则,被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。

3.进程的挂起

	当出现了引起进程挂起的事件时，比如,用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起,
	系统将利用挂起原语 suspend( )将指定进程挂起。挂起原语的执行过程是:首先检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程，则将之改为静止阻塞。


4.进程的激活过程

	当发生激活进程的事件时，例如，父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的该进程换入内存。
	这时，系统将利用激活原语 active( )将指定进程激活。激活原语先将进程从外存调入内存,
	检查该进程的现行状态，若是静止就绪，便将之改为活动就绪;
	若为静止阻塞，便将之改为活动阻塞。
	假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，
	如果被激活进程的优先级更低，就不必重新调度;否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。

## 进程的调度

	进程的调度:进程在不停的排队,如何从队列中选取下一个执行对象取决于调度算法。

## 进程同步

进程同步的主要任务是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地[共享资源]和相互合作，从而使程序的执行具有可再现性。

	临界资源
		在任意时刻,只允许一个进程正在使用

	信号量 => 信号量集

		1 整型信号量  只可以进行P/V 操作(wait signal)即对缓存区资源数量的 +1 / -1 操作
		2 记录 型信号量 （数据结构中包含一个链表  用于实现让权等待）
		3 信号量集   (AND 信号量机制 的扩充 ，进程所需要的资源可能是多种，当多种资源全部都空闲时,一次性分配,否则不分配,避免死锁现象

	管程机制

	虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进 程都必须自备同步操作 wait(S)和 signal(S)。
	这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。
	这样，在解决上述问题的过程中，便产生了一种新的进程同步工具——管程(Monitors)。
	（如果对程序不了解的开发人员为严格按照 临界资源的访问规则编写程序，那么很容易造成死锁）
	这有点类似有几队人进行排队，信号量只提供一个排队参考，让每一队自己定义排队的规则，而管程则 倾向于强制提供排队规则，

	管程的定义：
	系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。
	例 如，对一台电传机，可用与分配该资源有关的状态信息(busy 或 free)和对它执行请求与释放的操作，
	以及等待该资源的进程队列来描述。又如，一个FIFO队列，可用其队长、队首和队尾以及在该队列上执行的一组操作来描述。


## 进程间通信(IPC)

	本地进程间通信(单机中进程间通信)
		本地通过进程PID唯一标识一个进程

	网络进程间通信
		三元组（ip地址，协议，端口）唯一标识一个进程,网络中的进程通信就可以利用这个标志与其它进程进行交互

	按照通信的机制分类(3类)

		1 共享存储器系统

			共享数据结构 : 进程共用某些数据结构
			共享存储区   : 进程共享存储区

		2 消息传递系统(应用最为广泛的进程间通信机制,又称报文传递系统,优点:对分布式、网络、多处理机系统支持良好)

			根据实现方式的不同分为以下两种:
			直接通信
				发送进程直接调用OS提供的发送原语(原子性语句)send(Receiver,message)将信息发送至接收进程,接收进程调用接收原语receive(Sender,message)接收发送进程的信息
			间接通信
				发送进程调用OS提供的发送原语将消息发送至信箱(信箱是发送进程与接收进程约定共享的数据结构的一个实体,该实体用来暂存发送进程发送给目标进程的消息)
				接收进程从信箱中提取信息

		3 管道通信
			使用一个共享文件(俗称 pipe文件、管道文件)连接一对读写进程,实现进程间通信

			cat access.log | grep '2019-06-01'

			cat access.log 命令将输出信息写入pipe文件,写入完成后,管道符右边的 grep命令读取pipe文件内容,并将符合匹配规则的行输出到终端界面

		4 消息缓冲队列通信机制(广泛的应用在本地进程间通信)

			发送进程与接收进程之间存在一个消息队列(长度为N,最多容纳N条消息)
				发送进程可以向消息队列连续发送消息而不必等待(队列满时阻塞)
				接收进程可以直接从消息队列提取信息而不必等待(队列空时阻塞)

			由于该队列属于临界资源,所以执行insert原语前后,都要执行wait/signal操作


- 互斥信号量 mutex
- 资源信号量 sm
- 消息队列   mq